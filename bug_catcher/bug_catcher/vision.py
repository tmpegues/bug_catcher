"""
The script implements the Vision class for the 'bug_catcher' package.

It handles the low-level image processing tasks, including loading HSV calibration
data, generating binary masks for specific colors, detecting contours, and
tracking objects over time using the SORT algorithm.
"""

from bug_catcher.sort import Sort

import cv2

import numpy as np

import yaml


class Vision:
    """
    Vision processing backend for color detection and object tracking.

    Attributes
    ----------
    blur_ksize (int): Kernel size for Gaussian blur to reduce noise.
    tracker (Sort): Instance of the SORT tracker for persistent object IDs.
    colors (dict): Dictionary storing HSV thresholds (low, high) for each color.

    """

    def __init__(self):
        """Initialize the Vision processor."""
        # Kernel size for blurring
        self.blur_ksize = 11

        # Initialize the SORT tracker
        # max_age: Maximum number of frames to keep a track alive without detection
        # min_hits: Minimum number of consecutive detections before a track is confirmed
        # iou_threshold: Minimum IOU overlap to match a detection to a track
        # #################### Begin_Citation [13] ##################
        self.tracker = Sort(max_age=15, min_hits=3, iou_threshold=0.1)
        # #################### End_Citation [13] ##################

        # Dictionary to store loaded color profiles
        self.colors = {}

    def load_calibration(self, yaml_path):
        """
        Load color calibration data from a YAML file.

        Parses the file generated by the 'hsv_tuner' node and populates the
        internal colors dictionary.

        Args:
        ----
        yaml_path (str): Absolute path to the calibration YAML file.

        """
        print(f'Loading calibration from: {yaml_path}')
        with open(yaml_path, 'r') as f:
            data = yaml.safe_load(f)

        if data:
            for entry in data:
                name = entry['color']
                low = np.array(entry['hsv']['low'])
                high = np.array(entry['hsv']['high'])
                self.colors[name] = (low, high)
                print(f'Loaded color profile: {name}')

    def get_mask(self, frame, color_name):
        """
        Generate a binary mask for a specific color.

        Applies Gaussian blur, converts to HSV color space, thresholds the image
        based on calibrated values, and applies morphological operations to remove noise.

        Args:
        ----
        frame (np.ndarray): The input BGR video frame.
        color_name (str): The name of the color to mask (e.g., 'red').

        Returns
        -------
        mask (np.ndarray): Binary mask where white represents the target color.
                           Returns None if the color_name is not found.

        """
        if color_name not in self.colors:
            return None

        low_hsv, high_hsv = self.colors[color_name]

        # 1. Apply Gaussian Blur to reduce high-frequency noise
        blurred = cv2.GaussianBlur(frame, (self.blur_ksize, self.blur_ksize), 0)

        # 2. Convert from BGR to HSV color space
        hsv = cv2.cvtColor(blurred, cv2.COLOR_BGR2HSV)

        # 3. Apply Thresholding
        mask = cv2.inRange(hsv, low_hsv, high_hsv)

        # 4. Morphological Operations
        # Open: Removes small white noise (Erosion followed by Dilation)
        # Close: Fills small black holes inside objects (Dilation followed by Erosion)
        kernel = np.ones((5, 5), np.uint8)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

        return mask

    def detect_objects(self, frame, color_name):
        """
        Detect objects of a specific color within the frame.

        Finds external contours on the generated mask, filters them by area size,
        and prepares the bounding box data for the tracker.

        Args:
        ----
        frame (np.ndarray): The input video frame.
        color_name (str): The target color to detect.

        Returns
        -------
        detections (np.ndarray): Array of detections [x1, y1, x2, y2, score] for SORT.
        display_frame (np.ndarray): A copy of the frame with raw detection boxes drawn.

        """
        mask = self.get_mask(frame, color_name)
        if mask is None:
            return [], frame

        # Find external contours only (excludes nested contours)
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        detections = []
        display_frame = frame.copy()

        for cnt in contours:
            area = cv2.contourArea(cnt)

            # Filter out small noise artifacts
            if area < 500:
                continue

            x, y, w, h = cv2.boundingRect(cnt)

            # Format: [x1, y1, x2, y2, score]
            # Score is set to 1.0 as we are treating thresholding as absolute
            detections.append([x, y, x + w, y + h, 1.0])

            # Draw raw detection bounding box (Red) for debugging
            cv2.rectangle(display_frame, (x, y), (x + w, y + h), (0, 0, 255), 2)

        return np.array(detections), display_frame

    def update_tracker(self, detections, frame):
        """
        Update the SORT tracker with new detections and visualize results.

        Associates current detections with existing tracks to assign persistent IDs.

        Args:
        ----
        detections (np.ndarray): Array of current frame detections.
        frame (np.ndarray): The frame to draw tracking visualizations on.

        Returns
        -------
        results (list): List of tuples [(track_id, center_x, center_y), ...].
        frame (np.ndarray): The frame with tracking bounding boxes and IDs drawn.

        """
        if len(detections) == 0:
            detections = np.empty((0, 5))

        # Update SORT algorithm
        tracked_objects = self.tracker.update(detections)

        results = []

        for x1, y1, x2, y2, obj_id in tracked_objects:
            cx = int((x1 + x2) / 2)
            cy = int((y1 + y2) / 2)
            results.append((int(obj_id), cx, cy))

            # Visualization
            # Draw tracked bounding box (Green)
            cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), (0, 255, 0), 2)

            # Draw Track ID
            cv2.putText(
                frame,
                f'ID: {int(obj_id)}',
                (int(x1), int(y1) - 10),
                cv2.FONT_HERSHEY_SIMPLEX,
                0.6,
                (0, 255, 0),
                2,
            )

            # Draw Center Point
            cv2.circle(frame, (cx, cy), 5, (255, 0, 0), -1)

        return results, frame
